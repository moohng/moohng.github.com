<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="专注前端，记录生活！"><meta name="keywords" content="Hexo, js, Nodejs, React, Vue, JavaScript, CSS3, 前端"><title>js中的异步处理：你想知道的都在这了 - 红颜漠</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="/categories/JavaScript/"><span>JavaScript</span></a></li><li><a href="/categories/React/"><span>React</span></a></li><li><a href="/categories/Vue/"><span>Vue</span></a></li><li><a href="/categories/全栈/"><span>全栈</span></a></li><li><a href="/categories/CSS/"><span>CSS</span></a></li><li><a href="/categories/其他/"><span>其他</span></a></li><li><a href="https://github.com/moohng"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">js中的异步处理：你想知道的都在这了</h1><ul class="meta"><li><i class="icon icon-author"></i>Kevin</li><li><i class="icon icon-clock"></i>25 Minutes</li><li><i class="icon icon-calendar"></i>2017年9月6日</li></ul></div></div><div class="article-content" style="max-width:800px"><p>假如你已经知道了什么是异步，并且已经写过很多的异步代码。这篇文章主要介绍几种对异步代码的处理，即异步编码姿势：</p>
<ol>
<li>回调函数；</li>
<li>Promise；</li>
<li>迭代器、生成器；</li>
<li>async/await。</li>
</ol>
<p>重点在第3、4部分。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>这个没什么好说的，直接看一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'config.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>后面部分都以该<em>读取文件操作</em>为例来讲解。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><code>Promise</code>就是为异步而生的，主要是为了解决所谓的<em>回调地狱</em>问题。<code>Promise</code>的三个状态：<code>pending</code>，<code>fulfilled</code>和<code>rejected</code>。</p>
<p>通常的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">'config.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>需要注意一点的是：<code>new Promise()</code>传入的函数会立即执行，<code>then</code>跟<code>catch</code>中传入的函数才是异步执行的。</p>
<p><code>then</code>方法何时执行？取决于两点：</p>
<ol>
<li><code>promise</code>何时变成完成状态（<code>fulfilled</code>）；</li>
<li>在异步队列中的位置。</li>
</ol>
<h2 id="迭代器、生成器"><a href="#迭代器、生成器" class="headerlink" title="迭代器、生成器"></a>迭代器、生成器</h2><h3 id="概念的理解"><a href="#概念的理解" class="headerlink" title="概念的理解"></a>概念的理解</h3><p>先理解两个概念：<strong>生成器是一个返回迭代器的函数；那么迭代器就是生成器执行后返回的结果（对象）</strong>。所以，生成器是函数，迭代器是对象（很容易弄混的两个概念）。</p>
<p>首先，生成器是一个<strong>函数</strong>，这是一个特殊的函数，函数定义如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这就是一个生成器（函数）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">yield</span> a + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> b + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就是一个迭代器（对象）</span></span><br><span class="line"><span class="keyword">const</span> iterator = createIterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注释部分是next方法执行的返回值</span></span><br><span class="line">iterator.next(<span class="number">5</span>);    <span class="comment">// &#123;value: 1, done: false&#125;      执行完这句并没有给a赋值</span></span><br><span class="line">iterator.next(<span class="number">1</span>);    <span class="comment">// &#123;value: 3, done: false&#125;      执行这句的时候才会给a赋值1，（next传进去的值）</span></span><br><span class="line">iterator.next(<span class="number">5</span>);   <span class="comment">// &#123;value: 8, done: false&#125;      执行这句的时候才会给b赋值5</span></span><br><span class="line">iterator.next();    <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>yield 返回值取决于 next 方法传进去的值，不是 yield 后面表达式的值</p>
</blockquote>
<h3 id="异步的实现"><a href="#异步的实现" class="headerlink" title="异步的实现"></a>异步的实现</h3><p>看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个读取文件的函数，下面所有用到的地方均来自于此</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是node.js中一个简单的读取文件的异步操作，因为用了<code>Promise</code>，所以正常的使用应该是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">readFile(<span class="string">'config.json'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>其实这就是上面介绍的<code>Promise</code>对异步的处理。假如我们有这样一个想法，希望代码是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步读取，避免回调</span></span><br><span class="line">    <span class="keyword">const</span> data = readFile(<span class="string">'config.json'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，正常情况下，这段代码肯定不会如期执行，因为我们的<code>data</code>其实是一个<code>promise</code>对象。但是假如有这样一个<strong>容器</strong>，它能如期的执行我们上面的这段代码，我们只需要把代码丢进这个特殊的容器里。注意到没有，上面这段代码其实是一段同步的代码，通过同步的代码实现异步的操作，这似乎是一个很完美的想法，只是首先我们需要有这样的一个容器。</p>
<h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>运行异步代码的容器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行生成器函数的一个容器</span></span><br><span class="line"><span class="comment">// 参数必须是一个生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建迭代器</span></span><br><span class="line">    <span class="keyword">const</span> task = gen();</span><br><span class="line">    <span class="comment">// 开始执行</span></span><br><span class="line">    <span class="keyword">let</span> result = task.next();</span><br><span class="line"></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">            <span class="comment">// 用Promise处理</span></span><br><span class="line">            <span class="comment">// 解释：无论result.value本身是不是promise对象，都会作为一个promise对象来异步处理</span></span><br><span class="line">            <span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve(result.value);</span><br><span class="line">            promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 把本次执行的结果返回</span></span><br><span class="line">                <span class="comment">// 也就是语句 const value = yield func(); 的返回值</span></span><br><span class="line">                result = task.next(value);</span><br><span class="line">                <span class="comment">// 继续</span></span><br><span class="line">                step();</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                result = task.throw(err);</span><br><span class="line">                <span class="comment">// 继续</span></span><br><span class="line">                step();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们有了这样的一个容器<code>run</code>，把<em>读取文件的那段“同步”代码</em>丢进这个容器里：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注意这里多了一个 yield</span></span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">yield</span> readFile(<span class="string">'config.json'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在，我们的代码便能如期的执行了！</p>
<p>简单的解释一下，我们将<em>读取文件的这段“同步”代码</em>包装成了一个生成器函数，然后传给<code>run</code>函数去处理。在<code>run</code>函数内部首先执行这个生成器函数并返回了一个迭代器对象，当第一次执行<code>let result = task.next()</code>的时候，执行的就是<code>readFile(&#39;config.json&#39;)</code>这句，而这个函数会异步去读取文件并立马返回一个<code>promise</code>对象。所以<code>result</code>的值就是<code>{value: promise, done: false}</code>。由于<code>result.value</code>本身是一个<code>promise</code>对象，所以执行<code>const promise = Promise.resolve(result.value)</code>这句的时候返回的仍然是传入的那个<code>promise</code>对象（也就是<code>result.value</code>）。当读取文件操作完成之后，才会执行<code>then</code>或<code>catch</code>中的代码，在<code>then</code>中<code>result = task.next(value)</code>这句代码就会让之前卡住的<code>yield readFile(&#39;config.json&#39;)</code>往后执行，也就是<code>data</code>接收到<code>value</code>的值，然后打印出来。</p>
<p>如果你对<strong>迭代器/生成器</strong>这块不熟的话，理解起来可能比较痛苦，建议先去补补这方面的知识。</p>
<p>其实，<code>github</code>上已经有人提供了<code>run</code>这样的容器，叫做<a href="https://github.com/tj/co" target="_blank" rel="noopener">co</a>。所以，我们只要把注意力放在容器中的生成器里面的代码上面就可以了。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>在<code>run</code>容器中<code>yield</code>之后所有的代码都已经是异步执行的了，所以不管<code>yield</code>后面跟的是不是一个<code>promise</code>对象，后面的代码都是异步的。看一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run 开始执行'</span>);</span><br><span class="line">    <span class="keyword">const</span> sum = <span class="keyword">yield</span> add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sum:'</span>, sum);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'结束了！'</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码中<code>yield</code>后面跟的是一个<code>add</code>函数，函数的返回值是一个数值<code>3</code>，并非一个<code>promise</code>对象或其他异步操作。但这段代码执行的结果是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run 开始执行</span></span><br><span class="line"><span class="comment">// 结束了！</span></span><br><span class="line"><span class="comment">// sum: 3</span></span><br></pre></td></tr></table></figure>
<p>哪怕<code>yield</code>后面跟的不是一个函数，直接是一个数值<code>3</code>，执行的结果也是跟上面一样。</p>
<p>为什么？</p>
<p>注意在<code>run</code>中，我们是通过<code>Promise.resolve(result.value)</code>来处理的，<code>result.value</code>就是<code>yield</code>后面跟的东西。对<code>Promise</code>比较熟悉的话应该知道，<code>Promise.resolve()</code>传入的参数如果是一个<code>promise</code>对象，那么直接返回这个对象，如果传入的不是一个<code>promise</code>对象，那么会返回一个新创建的<code>promise</code>对象，并且是完成状态。也就是说<code>Promise.resolve</code>无论如何都会返回一个<code>promise</code>对象，而只有执行了<code>then</code>方法中的<code>result = task.next(value)</code>这句代码之后，<code>yield</code>之后的代码才会继续执行，（<code>sum</code>也才会接收到传过来的值）。因为<code>result = task.next(value)</code>是异步执行的，所以<code>yield</code>之后的代码自然就是异步的了。</p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>如果你看懂了上面的介绍，那么理解<code>async/await</code>就很轻松了；如果你觉得上面的写法很操蛋，那么下面的写法就是一个字爽。</p>
<h3 id="异步实现"><a href="#异步实现" class="headerlink" title="异步实现"></a>异步实现</h3><p>先直接上代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的 readFile 是上面定义的函数</span></span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> readFile(<span class="string">'config.json'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br></pre></td></tr></table></figure>
<p>就是这么简单！一眼看上去，跟上面第3部分的代码有些相像，只是<code>yield</code>变成了<code>await</code>，<code>*</code>变成了<code>async</code>，外面多了一个容器<code>run</code>。</p>
<p>再对比代码的执行顺序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run 开始执行'</span>);</span><br><span class="line">    <span class="keyword">const</span> sum = <span class="keyword">await</span> add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sum:'</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'结束了！'</span>);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run 开始执行</span></span><br><span class="line"><span class="comment">// 结束了！</span></span><br><span class="line"><span class="comment">// sum: 3</span></span><br></pre></td></tr></table></figure>
<p>有木有很惊讶？就连执行的顺序都跟<strong>yield</strong>实现的方式一样。而且再也不用管什么<strong>容器</strong>了，看上去更加直观。这就是所谓的<em>用同步的代码方式去写异步的操作</em>，借用一下老外的说法：让那些烦人的回调见鬼去吧。</p>
<p>虽然这里不用管什么<strong>运行容器</strong>之类的东西了，但是理解它实现的原理还是很重要的。我不知道<code>async/await</code>是否可以理解成<code>yield</code>实现异步的语法糖，只不过<code>async/await</code>纳入ES7的标准了，而<code>yield</code>的写法是我们自己实现的（比如运行容器<code>run</code>就是我们自己封装的，你也可以根据需求扩展出更强大的功能来）。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢阅读和分享！</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/async/">async</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/await/">await</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/promise/">promise</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yield/">yield</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异步/">异步</a><span class="tag-list-count">1</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">1</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjlf039ys0009fwuthj9vk20m" data-title="js中的异步处理：你想知道的都在这了" data-url="http://moohng.com/2017/09/06/cjlf039ys0009fwuthj9vk20m/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/09/07/cjlf039yu000afwutd7xw1bwv/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/08/10/cjlf039yn0005fwut9g5rbagx/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/moohng" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/moohng" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="https://www.segmentfault.com/u/bon" title="SegmentFault" target="_blank"><i class="icon icon-segmentfault"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2018 红颜漠<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>